<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>likelihood.graph.nn API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>likelihood.graph.nn</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="likelihood.graph.nn.cal_adjacency_matrix"><code class="name flex">
<span>def <span class="ident">cal_adjacency_matrix</span></span>(<span>df: pandas.core.frame.DataFrame,<br>exclude_subset: List[str] = [],<br>sparse: bool = True,<br>**kwargs) ‑> Tuple[dict, numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cal_adjacency_matrix(
    df: pd.DataFrame, exclude_subset: List[str] = [], sparse: bool = True, **kwargs
) -&gt; Tuple[dict, np.ndarray]:
    &#34;&#34;&#34;
    Calculates the adjacency matrix for a given DataFrame using parallel processing.

    Parameters
    ----------
    df : `DataFrame`
        The input DataFrame containing the features.
    exclude_subset : `List[str]`, `optional`
        A list of features to exclude from the calculation of the adjacency matrix.
    sparse : `bool`, `optional`
        Whether to return a sparse matrix or a dense matrix.
    **kwargs : `dict`
        Additional keyword arguments to pass to the `compare_similarity` function.

    Returns
    -------
    adj_dict : `dict`
        A dictionary containing the features.
    adjacency_matrix : `ndarray`
        The adjacency matrix.

    Keyword Arguments:
    ----------
    similarity: `int`
        The minimum number of features that must be the same in both arrays to be considered similar.
    threshold : `float`
        The threshold value used in the `compare_similarity` function. Default is 0.0
    &#34;&#34;&#34;
    if len(exclude_subset) &gt; 0:
        columns = [col for col in df.columns if col not in exclude_subset]
        df_ = df[columns].copy()
    else:
        df_ = df.copy()

    assert len(df_) &gt; 0

    similarity = kwargs.get(&#34;similarity&#34;, len(df_.columns) - 1)
    threshold = kwargs.get(&#34;threshold&#34;, 0.05)
    assert similarity &lt;= df_.shape[1]

    data = df_.to_numpy()
    n = len(data)

    adj_dict = {i: data[i].tolist() for i in range(n)}

    def pair_generator():
        for i in range(n):
            for j in range(i, n):
                yield (i, j)

    with Pool(cpu_count()) as pool:
        results = pool.starmap(
            compare_pair, ((pair, data, similarity, threshold) for pair in pair_generator())
        )

    adjacency_matrix = np.zeros((n, n), dtype=np.uint8)
    for i, j, val in results:
        if val:
            adjacency_matrix[i, j] = 1
            adjacency_matrix[j, i] = 1

    if sparse:
        num_nodes = adjacency_matrix.shape[0]

        indices = np.argwhere(adjacency_matrix != 0.0)
        indices = tf.constant(indices, dtype=tf.int64)
        values = tf.constant(adjacency_matrix[indices[:, 0], indices[:, 1]], dtype=tf.float32)
        adjacency_matrix = tf.sparse.SparseTensor(
            indices=indices, values=values, dense_shape=(num_nodes, num_nodes)
        )

    return adj_dict, adjacency_matrix</code></pre>
</details>
<div class="desc"><p>Calculates the adjacency matrix for a given DataFrame using parallel processing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The input DataFrame containing the features.</dd>
<dt><strong><code>exclude_subset</code></strong> :&ensp;<code>List[str]<code>,</code>optional</code></dt>
<dd>A list of features to exclude from the calculation of the adjacency matrix.</dd>
<dt><strong><code>sparse</code></strong> :&ensp;<code>bool<code>,</code>optional</code></dt>
<dd>Whether to return a sparse matrix or a dense matrix.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional keyword arguments to pass to the <code>compare_similarity</code> function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>adj_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the features.</dd>
<dt><strong><code>adjacency_matrix</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The adjacency matrix.</dd>
</dl>
<h2 id="keyword-arguments">Keyword Arguments:</h2>
<p>similarity: <code>int</code>
The minimum number of features that must be the same in both arrays to be considered similar.
threshold : <code>float</code>
The threshold value used in the <code>compare_similarity</code> function. Default is 0.0</p></div>
</dd>
<dt id="likelihood.graph.nn.compare_pair"><code class="name flex">
<span>def <span class="ident">compare_pair</span></span>(<span>pair, data, similarity, threshold)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_pair(pair, data, similarity, threshold):
    i, j = pair
    sim = compare_similarity_np(data[i], data[j], threshold=threshold)
    return (i, j, 1 if sim &gt;= similarity else 0)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.compare_similarity_np"><code class="name flex">
<span>def <span class="ident">compare_similarity_np</span></span>(<span>arr1: numpy.ndarray, arr2: numpy.ndarray, threshold: float = 0.05) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_similarity_np(arr1: np.ndarray, arr2: np.ndarray, threshold: float = 0.05) -&gt; int:
    &#34;&#34;&#34;Vectorized similarity comparison between two numeric/categorical arrays.&#34;&#34;&#34;
    arr1 = np.asarray(arr1)
    arr2 = np.asarray(arr2)

    is_numeric = np.vectorize(
        lambda a, b: isinstance(a, (int, float)) and isinstance(b, (int, float))
    )(arr1, arr2)

    similarity = np.zeros_like(arr1, dtype=bool)

    if np.any(is_numeric):
        a_num = arr1[is_numeric].astype(float)
        b_num = arr2[is_numeric].astype(float)

        both_zero = (a_num == 0) &amp; (b_num == 0)
        nonzero = ~both_zero &amp; (a_num != 0) &amp; (b_num != 0)
        ratio = np.zeros_like(a_num)
        ratio[nonzero] = np.maximum(a_num[nonzero], b_num[nonzero]) / np.minimum(
            a_num[nonzero], b_num[nonzero]
        )
        numeric_similar = both_zero | ((1 - threshold &lt;= ratio) &amp; (ratio &lt;= 1 + threshold))

        similarity[is_numeric] = numeric_similar

    similarity[~is_numeric] = arr1[~is_numeric] == arr2[~is_numeric]

    return np.count_nonzero(similarity)</code></pre>
</details>
<div class="desc"><p>Vectorized similarity comparison between two numeric/categorical arrays.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="likelihood.graph.nn.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>df: pandas.core.frame.DataFrame,<br>target: str | None = None,<br>exclude_subset: List[str] = [],<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Data:
    def __init__(
        self,
        df: DataFrame,
        target: str | None = None,
        exclude_subset: List[str] = [],
        **kwargs,
    ):
        sparse = kwargs.get(&#34;sparse&#34;, True)
        threshold = kwargs.get(&#34;threshold&#34;, 0.05)
        _, adjacency = cal_adjacency_matrix(
            df, exclude_subset=exclude_subset, sparse=sparse, threshold=threshold
        )
        if target is not None:
            X = df.drop(columns=[target] + exclude_subset)
        else:
            X = df.drop(columns=exclude_subset)
        self.columns = X.columns
        X = X.to_numpy()
        self.x = np.asarray(X).astype(np.float32)
        self.adjacency = adjacency
        if target is not None:
            self.y = np.asarray(df[target].values).astype(np.int32)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN"><code class="flex name class">
<span>class <span class="ident">VanillaGNN</span></span>
<span>(</span><span>dim_in, dim_h, dim_out, rank=2, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.keras.utils.register_keras_serializable(package=&#34;Custom&#34;, name=&#34;VanillaGNN&#34;)
class VanillaGNN(tf.keras.Model):
    def __init__(self, dim_in, dim_h, dim_out, rank=2, **kwargs):
        super(VanillaGNN, self).__init__(**kwargs)
        self.dim_in = dim_in
        self.dim_h = dim_h
        self.dim_out = dim_out
        self.rank = rank

        self.gnn1 = VanillaGNNLayer(self.dim_in, self.dim_h, self.rank)
        self.gnn2 = VanillaGNNLayer(self.dim_h, self.dim_h, self.rank)
        self.gnn3 = VanillaGNNLayer(self.dim_h, self.dim_out, None)

    def call(self, x, adjacency):
        h = self.gnn1(x, adjacency)
        h = tf.nn.tanh(h)
        h = self.gnn2(h, adjacency)
        h = self.gnn3(h, adjacency)
        return tf.nn.softmax(h, axis=1)

    def f1_macro(self, y_true, y_pred):
        return f1_score(y_true, y_pred, average=&#34;macro&#34;)

    def compute_f1_score(self, logits, labels):
        predictions = tf.argmax(logits, axis=1, output_type=tf.int32)
        true_labels = tf.cast(labels, tf.int32)
        return self.f1_macro(true_labels.numpy(), predictions.numpy())

    def evaluate(self, x, adjacency, y):
        y = tf.cast(y, tf.int32)
        out = self(x, adjacency)
        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=out)
        loss = tf.reduce_mean(loss)
        f1 = round(self.compute_f1_score(out, y), 4)
        return loss.numpy(), f1

    def test(self, data):
        out = self(data.x, data.adjacency)
        test_f1 = self.compute_f1_score(out, data.y)
        return round(test_f1, 4)

    def predict(self, data):
        out = self(data.x, data.adjacency)
        return tf.argmax(out, axis=1, output_type=tf.int32).numpy()

    def get_config(self):
        config = {
            &#34;dim_in&#34;: self.dim_in,
            &#34;dim_h&#34;: self.dim_h,
            &#34;dim_out&#34;: self.dim_out,
            &#34;rank&#34;: self.rank,
        }
        base_config = super(VanillaGNN, self).get_config()
        return dict(list(base_config.items()) + list(config.items()))

    @classmethod
    def from_config(cls, config):
        return cls(
            dim_in=config[&#34;dim_in&#34;],
            dim_h=config[&#34;dim_h&#34;],
            dim_out=config[&#34;dim_out&#34;],
            rank=config[&#34;rank&#34;],
        )

    @tf.function
    def train_step(self, batch_x, batch_adjacency, batch_y, optimizer):
        with tf.GradientTape() as tape:
            out = self(batch_x, batch_adjacency)
            loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=batch_y, logits=out)
            loss = tf.reduce_mean(loss)
        gradients = tape.gradient(loss, self.trainable_variables)
        optimizer.apply_gradients(zip(gradients, self.trainable_variables))
        return loss

    def fit(self, data, epochs, batch_size, test_size=0.2, optimizer=&#34;adam&#34;):
        optimizers = {
            &#34;sgd&#34;: tf.keras.optimizers.SGD(),
            &#34;adam&#34;: tf.keras.optimizers.Adam(),
            &#34;adamw&#34;: tf.keras.optimizers.AdamW(),
            &#34;adadelta&#34;: tf.keras.optimizers.Adadelta(),
            &#34;rmsprop&#34;: tf.keras.optimizers.RMSprop(),
        }
        optimizer = optimizers[optimizer]
        train_losses = []
        train_f1_scores = []
        val_losses = []
        val_f1_scores = []

        num_nodes = len(data.x)
        split_index = int((1 - test_size) * num_nodes)

        X_train, X_test = data.x[:split_index], data.x[split_index:]
        y_train, y_test = data.y[:split_index], data.y[split_index:]

        adjacency_train = tf.sparse.slice(data.adjacency, [0, 0], [split_index, split_index])
        adjacency_test = tf.sparse.slice(
            data.adjacency,
            [split_index, split_index],
            [num_nodes - split_index, num_nodes - split_index],
        )

        batch_starts = np.arange(0, len(X_train), batch_size)
        for epoch in range(epochs):
            np.random.shuffle(batch_starts)
            for start in batch_starts:
                end = start + batch_size
                batch_x = X_train[start:end, :]
                batch_adjacency = tf.sparse.slice(
                    adjacency_train, [start, start], [batch_size, batch_size]
                )
                batch_y = y_train[start:end]
                train_loss = self.train_step(batch_x, batch_adjacency, batch_y, optimizer)

            train_loss, train_f1 = self.evaluate(X_train, adjacency_train, y_train)
            train_losses.append(train_loss)
            train_f1_scores.append(train_f1)

            if epoch % 5 == 0:
                clear_output(wait=True)
                val_loss, val_f1 = self.evaluate(X_test, adjacency_test, y_test)
                val_losses.append(val_loss)
                val_f1_scores.append(val_f1)
                print(
                    f&#34;Epoch {epoch:&gt;3} | Train Loss: {train_loss:.4f} | Train F1: {train_f1:.4f} | Val Loss: {val_loss:.4f} | Val F1: {val_f1:.4f}&#34;
                )

        return train_losses, train_f1_scores, val_losses, val_f1_scores</code></pre>
</details>
<div class="desc"><p>A model grouping layers into an object with training/inference features.</p>
<p>There are three ways to instantiate a <code>Model</code>:</p>
<h2 id="with-the-functional-api">With the "Functional API"</h2>
<p>You start from <code>Input</code>,
you chain layer calls to specify the model's forward pass,
and finally, you create your model from inputs and outputs:</p>
<pre><code class="language-python">inputs = keras.Input(shape=(37,))
x = keras.layers.Dense(32, activation=&quot;relu&quot;)(inputs)
outputs = keras.layers.Dense(5, activation=&quot;softmax&quot;)(x)
model = keras.Model(inputs=inputs, outputs=outputs)
</code></pre>
<p>Note: Only dicts, lists, and tuples of input tensors are supported. Nested
inputs are not supported (e.g. lists of list or dicts of dict).</p>
<p>A new Functional API model can also be created by using the
intermediate tensors. This enables you to quickly extract sub-components
of the model.</p>
<p>Example:</p>
<pre><code class="language-python">inputs = keras.Input(shape=(None, None, 3))
processed = keras.layers.RandomCrop(width=128, height=128)(inputs)
conv = keras.layers.Conv2D(filters=32, kernel_size=3)(processed)
pooling = keras.layers.GlobalAveragePooling2D()(conv)
feature = keras.layers.Dense(10)(pooling)

full_model = keras.Model(inputs, feature)
backbone = keras.Model(processed, conv)
activations = keras.Model(conv, feature)
</code></pre>
<p>Note that the <code>backbone</code> and <code>activations</code> models are not
created with <code>keras.Input</code> objects, but with the tensors that originate
from <code>keras.Input</code> objects. Under the hood, the layers and weights will
be shared across these models, so that user can train the <code>full_model</code>, and
use <code>backbone</code> or <code>activations</code> to do feature extraction.
The inputs and outputs of the model can be nested structures of tensors as
well, and the created models are standard Functional API models that support
all the existing APIs.</p>
<h2 id="by-subclassing-the-model-class">By subclassing the <code>Model</code> class</h2>
<p>In that case, you should define your
layers in <code>__init__()</code> and you should implement the model's forward pass
in <code>call()</code>.</p>
<pre><code class="language-python">class MyModel(keras.Model):
    def __init__(self):
        super().__init__()
        self.dense1 = keras.layers.Dense(32, activation=&quot;relu&quot;)
        self.dense2 = keras.layers.Dense(5, activation=&quot;softmax&quot;)

    def call(self, inputs):
        x = self.dense1(inputs)
        return self.dense2(x)

model = MyModel()
</code></pre>
<p>If you subclass <code>Model</code>, you can optionally have
a <code>training</code> argument (boolean) in <code>call()</code>, which you can use to specify
a different behavior in training and inference:</p>
<pre><code class="language-python">class MyModel(keras.Model):
    def __init__(self):
        super().__init__()
        self.dense1 = keras.layers.Dense(32, activation=&quot;relu&quot;)
        self.dense2 = keras.layers.Dense(5, activation=&quot;softmax&quot;)
        self.dropout = keras.layers.Dropout(0.5)

    def call(self, inputs, training=False):
        x = self.dense1(inputs)
        x = self.dropout(x, training=training)
        return self.dense2(x)

model = MyModel()
</code></pre>
<p>Once the model is created, you can config the model with losses and metrics
with <code>model.compile()</code>, train the model with <code>model.fit()</code>, or use the model
to do prediction with <code>model.predict()</code>.</p>
<h2 id="with-the-sequential-class">With the <code>Sequential</code> class</h2>
<p>In addition, <code>keras.Sequential</code> is a special case of model where
the model is purely a stack of single-input, single-output layers.</p>
<pre><code class="language-python">model = keras.Sequential([
    keras.Input(shape=(None, None, 3)),
    keras.layers.Conv2D(filters=32, kernel_size=3),
])
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>keras.src.models.model.Model</li>
<li>keras.src.backend.tensorflow.trainer.TensorFlowTrainer</li>
<li>keras.src.trainers.trainer.Trainer</li>
<li>keras.src.layers.layer.Layer</li>
<li>keras.src.backend.tensorflow.layer.TFLayer</li>
<li>keras.src.backend.tensorflow.trackable.KerasAutoTrackable</li>
<li>tensorflow.python.trackable.autotrackable.AutoTrackable</li>
<li>tensorflow.python.trackable.base.Trackable</li>
<li>keras.src.ops.operation.Operation</li>
<li>keras.src.saving.keras_saveable.KerasSaveable</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="likelihood.graph.nn.VanillaGNN.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an operation from its config.</p>
<p>This method is the reverse of <code>get_config</code>, capable of instantiating the
same operation from the config dictionary.</p>
<p>Note: If you override this method, you might receive a serialized dtype
config, which is a <code>dict</code>. You can deserialize it as follows:</p>
<pre><code class="language-python">if &quot;dtype&quot; in config and isinstance(config[&quot;dtype&quot;], dict):
    policy = dtype_policies.deserialize(config[&quot;dtype&quot;])
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>A Python dictionary, typically the output of <code>get_config</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An operation instance.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="likelihood.graph.nn.VanillaGNN.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, x, adjacency)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, x, adjacency):
    h = self.gnn1(x, adjacency)
    h = tf.nn.tanh(h)
    h = self.gnn2(h, adjacency)
    h = self.gnn3(h, adjacency)
    return tf.nn.softmax(h, axis=1)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.compute_f1_score"><code class="name flex">
<span>def <span class="ident">compute_f1_score</span></span>(<span>self, logits, labels)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_f1_score(self, logits, labels):
    predictions = tf.argmax(logits, axis=1, output_type=tf.int32)
    true_labels = tf.cast(labels, tf.int32)
    return self.f1_macro(true_labels.numpy(), predictions.numpy())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, x, adjacency, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, x, adjacency, y):
    y = tf.cast(y, tf.int32)
    out = self(x, adjacency)
    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=out)
    loss = tf.reduce_mean(loss)
    f1 = round(self.compute_f1_score(out, y), 4)
    return loss.numpy(), f1</code></pre>
</details>
<div class="desc"><p>Returns the loss value &amp; metrics values for the model in test mode.</p>
<p>Computation is done in batches (see the <code>batch_size</code> arg.)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Input data. It can be:
- A NumPy array (or array-like), or a list of arrays
(in case the model has multiple inputs).
- A backend-native tensor, or a list of tensors
(in case the model has multiple inputs).
- A dict mapping input names to the corresponding array/tensors,
if the model has named inputs.
- A <code>keras.utils.PyDataset</code> returning <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.
- A <code>tf.data.Dataset</code> yielding <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.
- A <code>torch.utils.data.DataLoader</code> yielding <code>(inputs, targets)</code>
or <code>(inputs, targets, sample_weights)</code>.
- A Python generator function yielding <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Target data. Like the input data <code>x</code>, it can be either NumPy
array(s) or backend-native tensor(s). If <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or a Python generator function,
<code>y</code> should not be specified since targets will be obtained from
<code>x</code>.</dd>
<dt><strong><code>batch_size</code></strong></dt>
<dd>Integer or <code>None</code>.
Number of samples per batch of computation.
If unspecified, <code>batch_size</code> will default to 32.
Do not specify the <code>batch_size</code> if your input data <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function
since they generate batches.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd><code>"auto"</code>, 0, 1, or 2. Verbosity mode.
0 = silent, 1 = progress bar, 2 = single line.
<code>"auto"</code> becomes 1 for most cases.
Note that the progress bar is not
particularly useful when logged to a file, so <code>verbose=2</code> is
recommended when not running interactively
(e.g. in a production environment). Defaults to <code>"auto"</code>.</dd>
<dt><strong><code>sample_weight</code></strong></dt>
<dd>Optional NumPy array or tensor of weights for
the training samples, used for weighting the loss function
(during training only). You can either pass a flat (1D)
NumPy array or tensor with the same length as the input samples
(1:1 mapping between weights and samples), or in the case of
temporal data, you can pass a 2D NumPy array or tensor with
shape <code>(samples, sequence_length)</code> to apply a different weight
to every timestep of every sample.
This argument is not supported when <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function.
Instead, provide <code>sample_weights</code> as the third element of <code>x</code>.
Note that sample weighting does not apply to metrics specified
via the <code>metrics</code> argument in <code>compile()</code>. To apply sample
weighting to your metrics, you can specify them via the
<code>weighted_metrics</code> in <code>compile()</code> instead.</dd>
<dt><strong><code>steps</code></strong></dt>
<dd>Integer or <code>None</code>.
Total number of steps (batches of samples) to draw before
declaring the evaluation round finished. If <code>steps</code> is <code>None</code>,
it will run until <code>x</code> is exhausted. In the case of an infinitely
repeating dataset, it will run indefinitely.</dd>
<dt><strong><code>callbacks</code></strong></dt>
<dd>List of <code>keras.callbacks.Callback</code> instances.
List of callbacks to apply during evaluation.</dd>
<dt><strong><code>return_dict</code></strong></dt>
<dd>If <code>True</code>, loss and metric results are returned as a
dict, with each key being the name of the metric.
If <code>False</code>, they are returned as a list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Scalar test loss (if the model has a single output and no metrics)
or list of scalars (if the model has multiple outputs
and/or metrics). The attribute <code>model.metrics_names</code> will give you
the display labels for the scalar outputs.</p></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.f1_macro"><code class="name flex">
<span>def <span class="ident">f1_macro</span></span>(<span>self, y_true, y_pred)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f1_macro(self, y_true, y_pred):
    return f1_score(y_true, y_pred, average=&#34;macro&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, data, epochs, batch_size, test_size=0.2, optimizer='adam')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, data, epochs, batch_size, test_size=0.2, optimizer=&#34;adam&#34;):
    optimizers = {
        &#34;sgd&#34;: tf.keras.optimizers.SGD(),
        &#34;adam&#34;: tf.keras.optimizers.Adam(),
        &#34;adamw&#34;: tf.keras.optimizers.AdamW(),
        &#34;adadelta&#34;: tf.keras.optimizers.Adadelta(),
        &#34;rmsprop&#34;: tf.keras.optimizers.RMSprop(),
    }
    optimizer = optimizers[optimizer]
    train_losses = []
    train_f1_scores = []
    val_losses = []
    val_f1_scores = []

    num_nodes = len(data.x)
    split_index = int((1 - test_size) * num_nodes)

    X_train, X_test = data.x[:split_index], data.x[split_index:]
    y_train, y_test = data.y[:split_index], data.y[split_index:]

    adjacency_train = tf.sparse.slice(data.adjacency, [0, 0], [split_index, split_index])
    adjacency_test = tf.sparse.slice(
        data.adjacency,
        [split_index, split_index],
        [num_nodes - split_index, num_nodes - split_index],
    )

    batch_starts = np.arange(0, len(X_train), batch_size)
    for epoch in range(epochs):
        np.random.shuffle(batch_starts)
        for start in batch_starts:
            end = start + batch_size
            batch_x = X_train[start:end, :]
            batch_adjacency = tf.sparse.slice(
                adjacency_train, [start, start], [batch_size, batch_size]
            )
            batch_y = y_train[start:end]
            train_loss = self.train_step(batch_x, batch_adjacency, batch_y, optimizer)

        train_loss, train_f1 = self.evaluate(X_train, adjacency_train, y_train)
        train_losses.append(train_loss)
        train_f1_scores.append(train_f1)

        if epoch % 5 == 0:
            clear_output(wait=True)
            val_loss, val_f1 = self.evaluate(X_test, adjacency_test, y_test)
            val_losses.append(val_loss)
            val_f1_scores.append(val_f1)
            print(
                f&#34;Epoch {epoch:&gt;3} | Train Loss: {train_loss:.4f} | Train F1: {train_f1:.4f} | Val Loss: {val_loss:.4f} | Val F1: {val_f1:.4f}&#34;
            )

    return train_losses, train_f1_scores, val_losses, val_f1_scores</code></pre>
</details>
<div class="desc"><p>Trains the model for a fixed number of epochs (dataset iterations).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Input data. It can be:
- A NumPy array (or array-like), or a list of arrays
(in case the model has multiple inputs).
- A backend-native tensor, or a list of tensors
(in case the model has multiple inputs).
- A dict mapping input names to the corresponding array/tensors,
if the model has named inputs.
- A <code>keras.utils.PyDataset</code> returning <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.
- A <code>tf.data.Dataset</code> yielding <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.
- A <code>torch.utils.data.DataLoader</code> yielding <code>(inputs, targets)</code>
or <code>(inputs, targets, sample_weights)</code>.
- A Python generator function yielding <code>(inputs, targets)</code> or
<code>(inputs, targets, sample_weights)</code>.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Target data. Like the input data <code>x</code>, it can be either NumPy
array(s) or backend-native tensor(s). If <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or a Python generator function,
<code>y</code> should not be specified since targets will be obtained from
<code>x</code>.</dd>
<dt><strong><code>batch_size</code></strong></dt>
<dd>Integer or <code>None</code>.
Number of samples per gradient update.
If unspecified, <code>batch_size</code> will default to 32.
Do not specify the <code>batch_size</code> if your input data <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function
since they generate batches.</dd>
<dt><strong><code>epochs</code></strong></dt>
<dd>Integer. Number of epochs to train the model.
An epoch is an iteration over the entire <code>x</code> and <code>y</code>
data provided
(unless the <code>steps_per_epoch</code> flag is set to
something other than None).
Note that in conjunction with <code>initial_epoch</code>,
<code>epochs</code> is to be understood as "final epoch".
The model is not trained for a number of iterations
given by <code>epochs</code>, but merely until the epoch
of index <code>epochs</code> is reached.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd><code>"auto"</code>, 0, 1, or 2. Verbosity mode.
0 = silent, 1 = progress bar, 2 = one line per epoch.
"auto" becomes 1 for most cases.
Note that the progress bar is not
particularly useful when logged to a file,
so <code>verbose=2</code> is recommended when not running interactively
(e.g., in a production environment). Defaults to <code>"auto"</code>.</dd>
<dt><strong><code>callbacks</code></strong></dt>
<dd>List of <code>keras.callbacks.Callback</code> instances.
List of callbacks to apply during training.
See <code>keras.callbacks</code>. Note
<code>keras.callbacks.ProgbarLogger</code> and
<code>keras.callbacks.History</code> callbacks are created
automatically and need not be passed to <code>model.fit()</code>.
<code>keras.callbacks.ProgbarLogger</code> is created
or not based on the <code>verbose</code> argument in <code>model.fit()</code>.</dd>
<dt><strong><code>validation_split</code></strong></dt>
<dd>Float between 0 and 1.
Fraction of the training data to be used as validation data.
The model will set apart this fraction of the training data,
will not train on it, and will evaluate the loss and any model
metrics on this data at the end of each epoch. The validation
data is selected from the last samples in the <code>x</code> and <code>y</code> data
provided, before shuffling.
This argument is only supported when <code>x</code> and <code>y</code> are made of
NumPy arrays or tensors.
If both <code>validation_data</code> and <code>validation_split</code> are provided,
<code>validation_data</code> will override <code>validation_split</code>.</dd>
<dt><strong><code>validation_data</code></strong></dt>
<dd>Data on which to evaluate
the loss and any model metrics at the end of each epoch.
The model will not be trained on this data. Thus, note the fact
that the validation loss of data provided using
<code>validation_split</code> or <code>validation_data</code> is not affected by
regularization layers like noise and dropout.
<code>validation_data</code> will override <code>validation_split</code>.
It can be:
- A tuple <code>(x_val, y_val)</code> of NumPy arrays or tensors.
- A tuple <code>(x_val, y_val, val_sample_weights)</code> of NumPy
arrays.
- A <code>keras.utils.PyDataset</code>, a <code>tf.data.Dataset</code>, a
<code>torch.utils.data.DataLoader</code> yielding <code>(inputs, targets)</code> or a
Python generator function yielding <code>(x_val, y_val)</code> or
<code>(inputs, targets, sample_weights)</code>.</dd>
<dt><strong><code>shuffle</code></strong></dt>
<dd>Boolean, whether to shuffle the training data before each
epoch. This argument is ignored when <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function.</dd>
<dt><strong><code>class_weight</code></strong></dt>
<dd>Optional dictionary mapping class indices (integers)
to a weight (float) value, used for weighting the loss function
(during training only).
This can be useful to tell the model to
"pay more attention" to samples from
an under-represented class. When <code>class_weight</code> is specified
and targets have a rank of 2 or greater, either <code>y</code> must be
one-hot encoded, or an explicit final dimension of <code>1</code> must
be included for sparse class labels.</dd>
<dt><strong><code>sample_weight</code></strong></dt>
<dd>Optional NumPy array or tensor of weights for
the training samples, used for weighting the loss function
(during training only). You can either pass a flat (1D)
NumPy array or tensor with the same length as the input samples
(1:1 mapping between weights and samples), or in the case of
temporal data, you can pass a 2D NumPy array or tensor with
shape <code>(samples, sequence_length)</code> to apply a different weight
to every timestep of every sample.
This argument is not supported when <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function.
Instead, provide <code>sample_weights</code> as the third element of <code>x</code>.
Note that sample weighting does not apply to metrics specified
via the <code>metrics</code> argument in <code>compile()</code>. To apply sample
weighting to your metrics, you can specify them via the
<code>weighted_metrics</code> in <code>compile()</code> instead.</dd>
<dt><strong><code>initial_epoch</code></strong></dt>
<dd>Integer.
Epoch at which to start training
(useful for resuming a previous training run).</dd>
<dt><strong><code>steps_per_epoch</code></strong></dt>
<dd>Integer or <code>None</code>.
Total number of steps (batches of samples) before declaring one
epoch finished and starting the next epoch. When training with
input tensors or NumPy arrays, the default <code>None</code> means that the
value used is the number of samples in your dataset divided by
the batch size, or 1 if that cannot be determined.
If <code>x</code> is a <code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function, the
epoch will run until the input dataset is exhausted. When
passing an infinitely repeating dataset, you must specify the
<code>steps_per_epoch</code> argument, otherwise the training will run
indefinitely.</dd>
<dt><strong><code>validation_steps</code></strong></dt>
<dd>Integer or <code>None</code>.
Only relevant if <code>validation_data</code> is provided.
Total number of steps (batches of samples) to draw before
stopping when performing validation at the end of every epoch.
If <code>validation_steps</code> is <code>None</code>, validation will run until the
<code>validation_data</code> dataset is exhausted. In the case of an
infinitely repeating dataset, it will run indefinitely. If
<code>validation_steps</code> is specified and only part of the dataset
is consumed, the evaluation will start from the beginning of the
dataset at each epoch. This ensures that the same validation
samples are used every time.</dd>
<dt><strong><code>validation_batch_size</code></strong></dt>
<dd>Integer or <code>None</code>.
Number of samples per validation batch.
If unspecified, will default to <code>batch_size</code>.
Do not specify the <code>validation_batch_size</code> if your data is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function
since they generate batches.</dd>
<dt><strong><code>validation_freq</code></strong></dt>
<dd>Only relevant if validation data is provided.
Specifies how many training epochs to run
before a new validation run is performed,
e.g. <code>validation_freq=2</code> runs validation every 2 epochs.</dd>
</dl>
<p>Unpacking behavior for iterator-like inputs:
A common pattern is to pass an iterator like object such as a
<code>tf.data.Dataset</code> or a <code>keras.utils.PyDataset</code> to <code>fit()</code>,
which will in fact yield not only features (<code>x</code>)
but optionally targets (<code>y</code>) and sample weights (<code>sample_weight</code>).
Keras requires that the output of such iterator-likes be
unambiguous. The iterator should return a tuple
of length 1, 2, or 3, where the optional second and third elements
will be used for <code>y</code> and <code>sample_weight</code> respectively.
Any other type provided will be wrapped in
a length-one tuple, effectively treating everything as <code>x</code>. When
yielding dicts, they should still adhere to the top-level tuple
structure,
e.g. <code>({"x0": x0, "x1": x1}, y)</code>. Keras will not attempt to separate
features, targets, and weights from the keys of a single dict.
A notable unsupported data type is the <code>namedtuple</code>. The reason is
that it behaves like both an ordered datatype (tuple) and a mapping
datatype (dict). So given a namedtuple of the form:
<code>namedtuple("example_tuple", ["y", "x"])</code>
it is ambiguous whether to reverse the order of the elements when
interpreting the value. Even worse is a tuple of the form:
<code>namedtuple("other_tuple", ["x", "y", "z"])</code>
where it is unclear if the tuple was intended to be unpacked
into <code>x</code>, <code>y</code>, and <code>sample_weight</code> or passed through
as a single element to <code>x</code>.</p>
<h2 id="returns">Returns</h2>
<p>A <code>History</code> object. Its <code>History.history</code> attribute is
a record of training loss values and metrics values
at successive epochs, as well as validation loss values
and validation metrics values (if applicable).</p></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    config = {
        &#34;dim_in&#34;: self.dim_in,
        &#34;dim_h&#34;: self.dim_h,
        &#34;dim_out&#34;: self.dim_out,
        &#34;rank&#34;: self.rank,
    }
    base_config = super(VanillaGNN, self).get_config()
    return dict(list(base_config.items()) + list(config.items()))</code></pre>
</details>
<div class="desc"><p>Returns the config of the object.</p>
<p>An object config is a Python dictionary (serializable)
containing the information needed to re-instantiate it.</p></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, data):
    out = self(data.x, data.adjacency)
    return tf.argmax(out, axis=1, output_type=tf.int32).numpy()</code></pre>
</details>
<div class="desc"><p>Generates output predictions for the input samples.</p>
<p>Computation is done in batches. This method is designed for batch
processing of large numbers of inputs. It is not intended for use inside
of loops that iterate over your data and process small numbers of inputs
at a time.</p>
<p>For small numbers of inputs that fit in one batch,
directly use <code>__call__()</code> for faster execution, e.g.,
<code>model(x)</code>, or <code>model(x, training=False)</code> if you have layers such as
<code>BatchNormalization</code> that behave differently during
inference.</p>
<p>Note: See <a href="https://keras.io/getting_started/faq/#whats-the-difference-between-model-methods-predict-and-call">this FAQ entry</a>
for more details about the difference between <code>Model</code> methods
<code>predict()</code> and <code>__call__()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Input data. It can be:
- A NumPy array (or array-like), or a list of arrays
(in case the model has multiple inputs).
- A backend-native tensor, or a list of tensors
(in case the model has multiple inputs).
- A dict mapping input names to the corresponding array/tensors,
if the model has named inputs.
- A <code>keras.utils.PyDataset</code>.
- A <code>tf.data.Dataset</code>.
- A <code>torch.utils.data.DataLoader</code>.
- A Python generator function.</dd>
<dt><strong><code>batch_size</code></strong></dt>
<dd>Integer or <code>None</code>.
Number of samples per batch of computation.
If unspecified, <code>batch_size</code> will default to 32.
Do not specify the <code>batch_size</code> if your input data <code>x</code> is a
<code>keras.utils.PyDataset</code>, <code>tf.data.Dataset</code>,
<code>torch.utils.data.DataLoader</code> or Python generator function
since they generate batches.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd><code>"auto"</code>, 0, 1, or 2. Verbosity mode.
0 = silent, 1 = progress bar, 2 = single line.
<code>"auto"</code> becomes 1 for most cases. Note that the progress bar
is not particularly useful when logged to a file,
so <code>verbose=2</code> is recommended when not running interactively
(e.g. in a production environment). Defaults to <code>"auto"</code>.</dd>
<dt><strong><code>steps</code></strong></dt>
<dd>Total number of steps (batches of samples) to draw before
declaring the prediction round finished. If <code>steps</code> is <code>None</code>,
it will run until <code>x</code> is exhausted. In the case of an infinitely
repeating dataset, it will run indefinitely.</dd>
<dt><strong><code>callbacks</code></strong></dt>
<dd>List of <code>keras.callbacks.Callback</code> instances.
List of callbacks to apply during prediction.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>NumPy array(s) of predictions.</p></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(self, data):
    out = self(data.x, data.adjacency)
    test_f1 = self.compute_f1_score(out, data.y)
    return round(test_f1, 4)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNN.train_step"><code class="name flex">
<span>def <span class="ident">train_step</span></span>(<span>self, batch_x, batch_adjacency, batch_y, optimizer)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.function
def train_step(self, batch_x, batch_adjacency, batch_y, optimizer):
    with tf.GradientTape() as tape:
        out = self(batch_x, batch_adjacency)
        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=batch_y, logits=out)
        loss = tf.reduce_mean(loss)
    gradients = tape.gradient(loss, self.trainable_variables)
    optimizer.apply_gradients(zip(gradients, self.trainable_variables))
    return loss</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="likelihood.graph.nn.VanillaGNNLayer"><code class="flex name class">
<span>class <span class="ident">VanillaGNNLayer</span></span>
<span>(</span><span>dim_in, dim_out, rank=None, kernel_initializer='glorot_uniform', **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@tf.keras.utils.register_keras_serializable(package=&#34;Custom&#34;, name=&#34;VanillaGNNLayer&#34;)
class VanillaGNNLayer(tf.keras.layers.Layer):
    def __init__(self, dim_in, dim_out, rank=None, kernel_initializer=&#34;glorot_uniform&#34;, **kwargs):
        super(VanillaGNNLayer, self).__init__(**kwargs)
        self.dim_out = dim_out
        self.rank = rank
        self.kernel_initializer = kernel_initializer
        self.linear = None

    def build(self, input_shape):
        if self.rank:
            self.linear = LoRALayer(self.dim_out, rank=self.rank)
        else:
            self.linear = tf.keras.layers.Dense(
                self.dim_out, use_bias=False, kernel_initializer=self.kernel_initializer
            )
        super(VanillaGNNLayer, self).build(input_shape)

    def call(self, x, adjacency):
        x = self.linear(x)
        x = tf.sparse.sparse_dense_matmul(adjacency, x)
        return x

    def get_config(self):
        config = super(VanillaGNNLayer, self).get_config()
        config.update(
            {
                &#34;dim_out&#34;: self.dim_out,
                &#34;rank&#34;: self.rank,
                &#34;kernel_initializer&#34;: (
                    None
                    if self.rank
                    else tf.keras.initializers.serialize(self.linear.kernel_initializer)
                ),
            }
        )
        return config</code></pre>
</details>
<div class="desc"><p>This is the class from which all layers inherit.</p>
<p>A layer is a callable object that takes as input one or more tensors and
that outputs one or more tensors. It involves <em>computation</em>, defined
in the <code>call()</code> method, and a <em>state</em> (weight variables). State can be
created:</p>
<ul>
<li>in <code>__init__()</code>, for instance via <code>self.add_weight()</code>;</li>
<li>in the optional <code>build()</code> method, which is invoked by the first
<code>__call__()</code> to the layer, and supplies the shape(s) of the input(s),
which may not have been known at initialization time.</li>
</ul>
<p>Layers are recursively composable: If you assign a Layer instance as an
attribute of another Layer, the outer layer will start tracking the weights
created by the inner layer. Nested layers should be instantiated in the
<code>__init__()</code> method or <code>build()</code> method.</p>
<p>Users will just instantiate a layer and then treat it as a callable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trainable</code></strong></dt>
<dd>Boolean, whether the layer's variables should be trainable.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>String name of the layer.</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>The dtype of the layer's computations and weights. Can also be a
<code>keras.DTypePolicy</code>, which allows the computation and weight dtype
to differ. Defaults to <code>None</code>. <code>None</code> means to use
<code>keras.config.dtype_policy()</code>, which is a <code>float32</code> policy unless
set to different value (via <code>keras.config.set_dtype_policy()</code>).</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the layer (string).</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>Dtype of the layer's weights. Alias of <code>layer.variable_dtype</code>.</dd>
<dt><strong><code>variable_dtype</code></strong></dt>
<dd>Dtype of the layer's weights.</dd>
<dt><strong><code>compute_dtype</code></strong></dt>
<dd>The dtype of the layer's computations.
Layers automatically cast inputs to this dtype, which causes
the computations and output to also be in this dtype.
When mixed precision is used with a
<code>keras.DTypePolicy</code>, this will be different
than <code>variable_dtype</code>.</dd>
<dt><strong><code>trainable_weights</code></strong></dt>
<dd>List of variables to be included in backprop.</dd>
<dt><strong><code>non_trainable_weights</code></strong></dt>
<dd>List of variables that should not be
included in backprop.</dd>
<dt><strong><code>weights</code></strong></dt>
<dd>The concatenation of the lists trainable_weights and
non_trainable_weights (in this order).</dd>
<dt><strong><code>trainable</code></strong></dt>
<dd>Whether the layer should be trained (boolean), i.e.
whether its potentially-trainable weights should be returned
as part of <code>layer.trainable_weights</code>.</dd>
<dt><strong><code>input_spec</code></strong></dt>
<dd>Optional (list of) <code>InputSpec</code> object(s) specifying the
constraints on inputs that can be accepted by the layer.</dd>
</dl>
<p>We recommend that descendants of <code>Layer</code> implement the following methods:</p>
<ul>
<li><code>__init__()</code>: Defines custom layer attributes, and creates layer weights
that do not depend on input shapes, using <code>add_weight()</code>,
or other state.</li>
<li><code>build(self, input_shape)</code>: This method can be used to create weights that
depend on the shape(s) of the input(s), using <code>add_weight()</code>, or other
state. <code>__call__()</code> will automatically build the layer
(if it has not been built yet) by calling <code>build()</code>.</li>
<li><code>call(self, *args, **kwargs)</code>: Called in <code>__call__</code> after making
sure <code>build()</code> has been called. <code>call()</code> performs the logic of applying
the layer to the input arguments.
Two reserved keyword arguments you can optionally use in <code>call()</code> are:
1. <code>training</code> (boolean, whether the call is in inference mode or
training mode).
2. <code>mask</code> (boolean tensor encoding masked timesteps in the input,
used e.g. in RNN layers).
A typical signature for this method is <code>call(self, inputs)</code>, and user
could optionally add <code>training</code> and <code>mask</code> if the layer need them.</li>
<li><code>get_config(self)</code>: Returns a dictionary containing the configuration
used to initialize this layer. If the keys differ from the arguments
in <code>__init__()</code>, then override <code>from_config(self)</code> as well.
This method is used when saving
the layer or a model that contains this layer.</li>
</ul>
<p>Examples:</p>
<p>Here's a basic example: a layer with two variables, <code>w</code> and <code>b</code>,
that returns <code>y = w . x + b</code>.
It shows how to implement <code>build()</code> and <code>call()</code>.
Variables set as attributes of a layer are tracked as weights
of the layers (in <code>layer.weights</code>).</p>
<pre><code class="language-python">class SimpleDense(Layer):
    def __init__(self, units=32):
        super().__init__()
        self.units = units

    # Create the state of the layer (weights)
    def build(self, input_shape):
        self.kernel = self.add_weight(
            shape=(input_shape[-1], self.units),
            initializer=&quot;glorot_uniform&quot;,
            trainable=True,
            name=&quot;kernel&quot;,
        )
        self.bias = self.add_weight(
            shape=(self.units,),
            initializer=&quot;zeros&quot;,
            trainable=True,
            name=&quot;bias&quot;,
        )

    # Defines the computation
    def call(self, inputs):
        return ops.matmul(inputs, self.kernel) + self.bias

# Instantiates the layer.
linear_layer = SimpleDense(4)

# This will also call `build(input_shape)` and create the weights.
y = linear_layer(ops.ones((2, 2)))
assert len(linear_layer.weights) == 2

# These weights are trainable, so they're listed in `trainable_weights`:
assert len(linear_layer.trainable_weights) == 2
</code></pre>
<p>Besides trainable weights, updated via backpropagation during training,
layers can also have non-trainable weights. These weights are meant to
be updated manually during <code>call()</code>. Here's a example layer that computes
the running sum of its inputs:</p>
<pre><code class="language-python">class ComputeSum(Layer):

  def __init__(self, input_dim):
      super(ComputeSum, self).__init__()
      # Create a non-trainable weight.
      self.total = self.add_weight(
        shape=(),
        initializer=&quot;zeros&quot;,
        trainable=False,
        name=&quot;total&quot;,
      )

  def call(self, inputs):
      self.total.assign(self.total + ops.sum(inputs))
      return self.total

my_sum = ComputeSum(2)
x = ops.ones((2, 2))
y = my_sum(x)

assert my_sum.weights == [my_sum.total]
assert my_sum.non_trainable_weights == [my_sum.total]
assert my_sum.trainable_weights == []
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>keras.src.layers.layer.Layer</li>
<li>keras.src.backend.tensorflow.layer.TFLayer</li>
<li>keras.src.backend.tensorflow.trackable.KerasAutoTrackable</li>
<li>tensorflow.python.trackable.autotrackable.AutoTrackable</li>
<li>tensorflow.python.trackable.base.Trackable</li>
<li>keras.src.ops.operation.Operation</li>
<li>keras.src.saving.keras_saveable.KerasSaveable</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="likelihood.graph.nn.VanillaGNNLayer.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, input_shape)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, input_shape):
    if self.rank:
        self.linear = LoRALayer(self.dim_out, rank=self.rank)
    else:
        self.linear = tf.keras.layers.Dense(
            self.dim_out, use_bias=False, kernel_initializer=self.kernel_initializer
        )
    super(VanillaGNNLayer, self).build(input_shape)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNNLayer.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, x, adjacency)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, x, adjacency):
    x = self.linear(x)
    x = tf.sparse.sparse_dense_matmul(adjacency, x)
    return x</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="likelihood.graph.nn.VanillaGNNLayer.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    config = super(VanillaGNNLayer, self).get_config()
    config.update(
        {
            &#34;dim_out&#34;: self.dim_out,
            &#34;rank&#34;: self.rank,
            &#34;kernel_initializer&#34;: (
                None
                if self.rank
                else tf.keras.initializers.serialize(self.linear.kernel_initializer)
            ),
        }
    )
    return config</code></pre>
</details>
<div class="desc"><p>Returns the config of the object.</p>
<p>An object config is a Python dictionary (serializable)
containing the information needed to re-instantiate it.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="likelihood.graph" href="index.html">likelihood.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="likelihood.graph.nn.cal_adjacency_matrix" href="#likelihood.graph.nn.cal_adjacency_matrix">cal_adjacency_matrix</a></code></li>
<li><code><a title="likelihood.graph.nn.compare_pair" href="#likelihood.graph.nn.compare_pair">compare_pair</a></code></li>
<li><code><a title="likelihood.graph.nn.compare_similarity_np" href="#likelihood.graph.nn.compare_similarity_np">compare_similarity_np</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="likelihood.graph.nn.Data" href="#likelihood.graph.nn.Data">Data</a></code></h4>
</li>
<li>
<h4><code><a title="likelihood.graph.nn.VanillaGNN" href="#likelihood.graph.nn.VanillaGNN">VanillaGNN</a></code></h4>
<ul class="two-column">
<li><code><a title="likelihood.graph.nn.VanillaGNN.call" href="#likelihood.graph.nn.VanillaGNN.call">call</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.compute_f1_score" href="#likelihood.graph.nn.VanillaGNN.compute_f1_score">compute_f1_score</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.evaluate" href="#likelihood.graph.nn.VanillaGNN.evaluate">evaluate</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.f1_macro" href="#likelihood.graph.nn.VanillaGNN.f1_macro">f1_macro</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.fit" href="#likelihood.graph.nn.VanillaGNN.fit">fit</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.from_config" href="#likelihood.graph.nn.VanillaGNN.from_config">from_config</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.get_config" href="#likelihood.graph.nn.VanillaGNN.get_config">get_config</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.predict" href="#likelihood.graph.nn.VanillaGNN.predict">predict</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.test" href="#likelihood.graph.nn.VanillaGNN.test">test</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNN.train_step" href="#likelihood.graph.nn.VanillaGNN.train_step">train_step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="likelihood.graph.nn.VanillaGNNLayer" href="#likelihood.graph.nn.VanillaGNNLayer">VanillaGNNLayer</a></code></h4>
<ul class="">
<li><code><a title="likelihood.graph.nn.VanillaGNNLayer.build" href="#likelihood.graph.nn.VanillaGNNLayer.build">build</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNNLayer.call" href="#likelihood.graph.nn.VanillaGNNLayer.call">call</a></code></li>
<li><code><a title="likelihood.graph.nn.VanillaGNNLayer.get_config" href="#likelihood.graph.nn.VanillaGNNLayer.get_config">get_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
